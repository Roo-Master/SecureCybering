<!DOCTYPE html>
<html lang="en" class="h-full">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Data Nodes Network</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body,
    html {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
    }

    canvas#networkCanvas {
      position: fixed;
      top: 0;
      left: 0;
      z-index: -1;
    }

    .node-card {
      transition: transform 0.2s;
    }

    .node-card:hover {
      transform: scale(1.05);
    }
  </style>
</head>

<body class="bg-gray-50 dark:bg-gray-900 text-gray-900 dark:text-white h-full">

  <!-- Canvas for network visualization -->
  <canvas id="networkCanvas"></canvas>

  <!-- Header -->
  <header
    class="bg-white dark:bg-gray-800 shadow-lg border-b border-gray-200 dark:border-gray-700 p-6 flex justify-between items-center z-10 relative">
    <h1 class="text-2xl font-bold text-primary">Data Nodes Network</h1>
    <button onclick="location.reload()" class="px-4 py-2 bg-primary text-white rounded-lg hover:bg-opacity-90 transition-all">
      Refresh
    </button>
  </header>

  <!-- Nodes Overview -->
  <main class="p-6 relative z-10">
    <section class="mb-6">
      <h2 class="text-xl font-semibold mb-4">Peer Activity Overview</h2>
      <div id="dataNodesGrid" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4"></div>
    </section>
  </main>

  <script>
    const canvas = document.getElementById('networkCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Simulated peers
    const peers = Array.from({ length: 12 }, (_, i) => ({
      id: `Node-${String(i + 1).padStart(2, '0')}`,
      status: Math.random() > 0.1 ? 'active' : 'inactive',
      x: Math.random() * canvas.width * 0.8 + canvas.width * 0.1,
      y: Math.random() * canvas.height * 0.6 + canvas.height * 0.2,
      connections: []
    }));

    // Assign random connections
    function assignConnections() {
      peers.forEach(node => {
        node.connections = peers.filter(p => p !== node && Math.random() < 0.3)
          .map(conn => ({ target: conn, progress: Math.random() })); // Add progress for animation
      });
    }

    assignConnections();

    // Render nodes and connections
    function renderNetwork() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw connections
      peers.forEach(node => {
        node.connections.forEach(conn => {
          ctx.beginPath();
          ctx.moveTo(node.x, node.y);
          ctx.lineTo(conn.target.x, conn.target.y);
          ctx.strokeStyle =
            node.status === 'active' && conn.target.status === 'active' ? 'rgba(78,205,196,0.3)' : 'rgba(255,107,107,0.15)';
          ctx.lineWidth = 2;
          ctx.stroke();

          // Draw packet moving along connection
          const dx = conn.target.x - node.x;
          const dy = conn.target.y - node.y;
          const px = node.x + dx * conn.progress;
          const py = node.y + dy * conn.progress;
          ctx.beginPath();
          ctx.arc(px, py, 4, 0, Math.PI * 2);
          ctx.fillStyle = '#FFD700';
          ctx.fill();

          // Update progress
          conn.progress += 0.01;
          if (conn.progress > 1) conn.progress = 0;
        });
      });

      // Draw nodes
      peers.forEach(node => {
        ctx.beginPath();
        ctx.arc(node.x, node.y, 12, 0, Math.PI * 2);
        ctx.fillStyle = node.status === 'active' ? '#4ECDC4' : '#FF6B6B';
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
      });
    }

    // Animate nodes and packets
    function animateNetwork() {
      peers.forEach(node => {
        node.x += (Math.random() - 0.5) * 0.3;
        node.y += (Math.random() - 0.5) * 0.3;
      });
      renderNetwork();
      requestAnimationFrame(animateNetwork);
    }

    animateNetwork();

    // Render node cards
    function renderNodeCards() {
      const container = document.getElementById('dataNodesGrid');
      container.innerHTML = '';
      peers.forEach(node => {
        const card = document.createElement('div');
        card.className = `p-4 rounded-lg shadow-md border border-gray-200 dark:border-gray-700 node-card
          ${node.status === 'active' ? 'bg-green-50 dark:bg-green-900' : 'bg-gray-100 dark:bg-gray-800'}`;
        card.innerHTML = `
          <h3 class="font-semibold mb-2">${node.id}</h3>
          <p>Status: <span class="${node.status === 'active' ? 'text-green-600' : 'text-red-600'} font-medium">${node.status}</span></p>
          <p>Connections: <span class="font-mono">${node.connections.length}</span></p>
        `;
        container.appendChild(card);
      });
    }

    renderNodeCards();

    // Periodic peer status update
    setInterval(() => {
      peers.forEach(node => node.status = Math.random() > 0.1 ? 'active' : 'inactive');
      renderNodeCards();
    }, 5000);

    // Handle window resize
    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      peers.forEach(node => {
        node.x = Math.random() * canvas.width * 0.8 + canvas.width * 0.1;
        node.y = Math.random() * canvas.height * 0.6 + canvas.height * 0.2;
      });
    });
  </script>

</body>

</html>
